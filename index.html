<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<title>OpenLayers Kadastrale Kaart</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.3.0/ol.css" />
<style>
  html, body, #map {
    margin:0; padding:0; width:100%; height:100%;
  }
  .ol-popup {
    position: absolute;
    background-color: white;
    padding: 5px 10px;
    border: 1px solid #ccc;
    bottom: 12px;
    left: -50px;
    min-width: 200px;
  }
  .ol-popup:after, .ol-popup:before {
    top: 100%;
    border: solid transparent;
    content: " ";
    height: 0;
    width: 0;
    position: absolute;
    pointer-events: none;
  }
  .ol-popup:after {
    border-top-color: white;
    border-width: 10px;
    left: 48px;
    margin-left: -10px;
  }
  .ol-popup:before {
    border-top-color: #ccc;
    border-width: 11px;
    left: 48px;
    margin-left: -11px;
  }
</style>
</head>
<body>
<div id="map"></div>
<div id="popup" class="ol-popup" style="display:none;"></div>

<script src="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
  // Basiskaart OSM
  const map = new ol.Map({
    target: 'map',
    layers: [
      new ol.layer.Tile({
        source: new ol.source.OSM()
      })
    ],
    view: new ol.View({
      center: ol.proj.fromLonLat([5.775, 52.64]),
      zoom: 14
    })
  });

  // Popup div
  const popupContainer = document.getElementById('popup');

  // Popup overlay
  const popupOverlay = new ol.Overlay({
    element: popupContainer,
    positioning: 'bottom-center',
    stopEvent: false,
    offset: [0, -10]
  });
  map.addOverlay(popupOverlay);

  // Functie om popup content te maken uit tags object
  function createPopupContent(tags) {
    if(!tags) return '';
    let html = '<table><thead><tr><th>tag</th><th>waarde</th></tr></thead><tbody>';
    for(const [k,v] of Object.entries(tags)){
      html += `<tr><td>${k}</td><td>${v}</td></tr>`;
    }
    html += '</tbody></table>';
    return html;
  }

  // Style functie met label
  function featureStyle(feature, resolution) {
    const tags = feature.get('tags') || {};
    let labelText = '';
    if(tags['kad:perceelnr']){
      labelText = tags['kad:perceelnr'];
      if(tags['kad:perceelnrtvg']){
        labelText += '/' + tags['kad:perceelnrtvg'];
      }
    }
    // Alleen labels tonen bij zoom > ~18 (je kunt resolutie vergelijken)
    const showLabel = map.getView().getZoom() >= 18;
    return [
      new ol.style.Style({
        fill: new ol.style.Fill({
          color: 'rgba(255, 0, 0, 0.2)'
        }),
        stroke: new ol.style.Stroke({
          color: '#a10000',
          width: 2
        }),
        text: new ol.style.Text({
          font: 'bold 14px Calibri,sans-serif',
          text: showLabel ? labelText : '',
          fill: new ol.style.Fill({color: '#a10000'}),
          stroke: new ol.style.Stroke({color: 'white', width: 3}),
          overflow: true
        })
      })
    ];
  }

  // GeoJSON laden en vectorlaag aanmaken
  fetch('JOUW_GEOJSON_URL_HIER.json')
  .then(resp => resp.json())
  .then(geojson => {
    const vectorSource = new ol.source.Vector({
      features: new ol.format.GeoJSON().readFeatures(geojson, {
        featureProjection: 'EPSG:3857' // Zorg juiste projectie
      })
    });

    const vectorLayer = new ol.layer.Vector({
      source: vectorSource,
      style: featureStyle
    });

    map.addLayer(vectorLayer);

    // Klik event handler met Turf.js om binnen hole te detecteren
    map.on('singleclick', function(evt) {
      popupOverlay.setPosition(undefined);
      popupContainer.style.display = 'none';

      const clickedFeatures = [];
      map.forEachFeatureAtPixel(evt.pixel, function(feature) {
        clickedFeatures.push(feature);
      });

      if(clickedFeatures.length === 0) return;

      // Prioriteit gevend aan ways die niet binnen a hole zijn
      for(const feat of clickedFeatures){
        const geom = feat.getGeometry();
        const geojsonGeom = feat.getGeometry().clone().transform('EPSG:3857','EPSG:4326').getCoordinates();

        // Turf expect coordinates as array in lon,lat order
        let coordinates = feat.getGeometry().clone().transform('EPSG:3857','EPSG:4326').getCoordinates();

        const tags = feat.get('tags') || {};
        let geojsonForTurf = null;

        if(geom.getType() === 'Polygon'){
          geojsonForTurf = turf.polygon(coordinates);
        } else if(geom.getType() === 'MultiPolygon'){
          geojsonForTurf = turf.multiPolygon(coordinates);
        }

        if(geojsonForTurf){
          const clickPoint = turf.point(ol.proj.toLonLat(evt.coordinate));
          let inHole = false;
          const polyCoords = (geom.getType()==='Polygon') ? coordinates : (coordinates.length ? coordinates : []);

          if(Array.isArray(polyCoords)){
            for(let i=0; i<polyCoords.length; i++){
              // first ring is outer, others holes
              if(i===0) continue;
              const holePoly = turf.polygon([polyCoords[i]]);
              if(turf.booleanPointInPolygon(clickPoint, holePoly)){
                inHole = true;
                break;
              }
            }
          }
          if(inHole){
            console.log('Klik in hole, negeer feature');
            continue; // negeer
          } else {
            showPopupForFeature(feat, evt.coordinate);
            return;
          }
        } else {
          // geen polygon/multipolygon, toon popup
          showPopupForFeature(feat, evt.coordinate);
          return;
        }
      }

      // fallback geen feature tonen
      console.log('Geen feature popup getoond, mogelijk click in hole');
    });

    function showPopupForFeature(feature, coordinate){
      const tags = feature.get('tags') || {};
      const content = createPopupContent(tags);
      if(content){
        popupContainer.innerHTML = content;
        popupOverlay.setPosition(coordinate);
        popupContainer.style.display = 'block';
        console.log('Popup getoond met tags:', tags);
      }
    }

    // Update labels bij zoom wijziging (force style update)
    map.getView().on('change:resolution', () => {
      vectorLayer.setStyle(featureStyle);
      updateLabels(vectorSource);
    });

    // Markerlabels bovenop features als aparte markers
    function updateLabels(source){
      clearLabelMarkers();
      if(map.getView().getZoom()<18) return;
      source.getFeatures().forEach(feature => {
        const tags = feature.get('tags') || {};
        let labelText = tags['kad:perceelnr'] || '';
        if(tags['kad:perceelnrtvg']) labelText += '/' + tags['kad:perceelnrtvg'];
        if(!labelText) return;

        // Plaats label in geometrie centrum (gebruik getExtent)
        const ext = feature.getGeometry().getExtent();
        const center = ol.extent.getCenter(ext);

        const labelMarker = new ol.Overlay({
          position: center,
          element: createLabelElement(labelText),
          stopEvent: false
        });
        labelMarker.setMap(map);
        labelMarkers.push(labelMarker);
      });
    }

    function createLabelElement(text){
      const div = document.createElement('div');
      div.className = 'kadastraal-label';
      div.textContent = text;
      return div;
    }
  })
  .catch(e => {
    console.error('Fout bij laden GeoJSON:', e);
  });
</script>
</body>
</html>
